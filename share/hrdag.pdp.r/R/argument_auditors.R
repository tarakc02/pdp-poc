# -*- coding: utf-8 -*-
#
# Author: PB
# Maintainer(s): PB
# License: (c) HRDAG 2018, GPL v2 or newer
#
# pdp-poc/share/hrdag.pdp.r/R/argument_auditors.R
# -----------------------------------------------------------
#
#
#
# -----------------------------------------------------------

.get_running_name <- function() {
  #' returns name of current script
  if (interactive()) {
    fname <- rstudioapi::getActiveDocumentContext()$path
  } else {
    # via commandArgs, look for file=
    cmdArgs = commandArgs(trailingOnly = FALSE)
    needle <- '--file='
    fname <- grep(needle, cmdArgs, value=TRUE)
  }
  fname = tools::file_path_as_absolute(fname)
  if (length(fname) > 0) {
    fname <- basename(fname)
    return(tools::file_path_sans_ext(basename(fname)))
  } else {
    stop("unable to determine currently running script. quitting.")
  }
  return(FALSE)
}


.default_checker <- function(args, python_code) {
  #' checks the default arguments == arguments in python code
  #'
  #' @param args named list of arguments as returned by the parser
  #' @param python_code code generated by argparse parser specifications
  #'
  # note that argparse would complain if the number of args passed .!= number defined.
  for (line in python_code) {
    key <- stringr::str_sub(stringr::str_extract(line, '--[^,]+'), 3, -2)
    if (is.na(key)) next
    regex_patt <- 'default=[\'"].*[\'"]'
    pth <- stringr::str_sub(stringr::str_extract(line, regex_patt), 10, -2)
    stopifnot(args[[key]] == pth)
  }
  return(TRUE)
}

chkargs <- function(args, parser, addlog=TRUE) {
  #' checks the default arguments == arguments passed via command line
  #'
  #' @param args named list of arguments as returned by the parser
  #' @param parser parser object used to hold defaults and parse command line
  #'
  if (addlog & !"log" %in% names(args)) {
    fname <- .get_running_name()
    args[["log"]] <- str_glue('output/{fname}.log')
  }
  if (!interactive()) {
    .default_checker(args, parser$python_code)
  }
  return(args)
}



# done.
